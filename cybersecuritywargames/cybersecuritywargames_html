<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cybersecurity Wargaming Scenarios</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for League of Moveable Type fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Sorts+Mill+Goudy&family=Linden+Hill&family=Goudy+Bookletter+1911&family=Fanwood+Text&family=League+Gothic&family=League+Spartan&family=Raleway&family=Ostrich+Sans:wght@400&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Sorts Mill Goudy', serif; /* Default serif font, will be overridden for card text */
            background-color: #1a202c; /* Dark background for a game feel */
            display: flex;
            justify-content: center; /* Keep content horizontally centered (for card) */
            align-items: center; /* Keep content vertically centered (for card) */
            min-height: 100vh;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            flex-direction: column; /* Allow content to stack vertically */
            overflow-x: hidden; /* Prevent horizontal scrollbars from animation overflow */
            position: relative; /* Needed for absolute positioning of background */
        }

        #background-canvas {
            position: fixed; /* Use fixed to keep background static during scroll */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Behind the content */
            background-color: #1a202c; /* Ensure a base dark background */
        }

        .main-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem; /* Large font size for title */
            font-weight: 700;
            position: fixed; /* Fixed to keep it at the very top of the viewport */
            top: 0; /* Align to the very top */
            width: 100%; /* Take full width */
            padding-top: 20px; /* Space from the very top edge */
            z-index: 10; /* Ensure it's above all other content, including cards */
            text-align: center;
            /* Gradient text effect */
            background: linear-gradient(90deg, #00FF00, #009900); /* Green gradient */
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent; /* Make text color transparent to show gradient */
            -webkit-text-fill-color: transparent; /* For webkit browsers */
            transition: opacity 0.3s ease-out; /* Smooth fade effect */
        }

        #header-spacer {
            /* This div will create space for the fixed header */
            height: 100px; /* Approximate height of the title + its padding/margin */
            width: 100%; /* Take full width */
            flex-shrink: 0; /* Prevent it from shrinking */
            z-index: 1; /* Above background, below main content if needed */
        }

        .card-container {
            perspective: 1000px; /* For 3D effects */
            width: 280px; /* Fixed width */
            height: 448px; /* Increased fixed height (280 * 40/25 = 448) */
            display: flex; /* Using flex to center the card if needed, though absolute positioning takes over */
            justify-content: center;
            align-items: center;
            position: relative; /* Needed for absolute positioning of child cards */
            z-index: 1; /* Above the background */
            /* No margin-top needed here, spacer handles it */
        }
        .card {
            width: 100%;
            height: 100%;
            position: absolute; /* Position absolute for animation and layering */
            top: 0;
            left: 0;
            transform-style: preserve-3d; /* Keep for potential future 3D effects */
            transition: transform 0.6s ease-in-out, opacity 0.6s ease-in-out; /* Smooth transitions for movement and fade */
            cursor: pointer; /* Indicate it's clickable */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
            border-radius: 1rem; /* rounded-xl */
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
            /* Removed initial opacity and transform from here, now controlled by animation classes */
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Ensures only one side is visible at a time */
            border-radius: 1rem; /* rounded-xl */
            padding: 1.75rem; /* Adjusted padding for more buffer */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Keep content centered vertically */
            align-items: flex-start; /* Align content to the start (left) */
            text-align: left; /* Left-align text */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }
        .card-front {
            background: linear-gradient(135deg, #667eea, #764ba2); /* Default gradient */
            color: #e2e8f0; /* Light gray text */
            font-size: 1.75rem; /* Adjusted font size */
            font-weight: 700; /* font-bold */
            justify-content: center; /* Keep front face content centered */
            align-items: center; /* Keep front face content centered */
            text-align: center; /* Keep front face text centered */
            transform: rotateY(0deg); /* Front face is always unrotated relative to its parent */
        }
        .card-back {
            background: linear-gradient(135deg, #764ba2, #667eea); /* Default reversed gradient */
            color: #cbd5e0; /* Lighter gray text */
            transform: rotateY(180deg); /* Back face is rotated 180deg relative to its parent */
            position: relative; /* Needed for absolute positioning of ID elements */
        }

        /* Scenario ID styling */
        .scenario-id {
            font-family: monospace; /* Code font */
            font-size: 0.75rem; /* Small font size */
            color: rgba(255, 255, 255, 0.6); /* Slightly faded white */
            position: absolute;
            z-index: 10; /* Ensure it's above other content */
        }

        .scenario-id-top-left {
            top: 10px;
            left: 15px; /* Match card padding */
        }

        .scenario-id-bottom-right {
            bottom: 10px;
            right: 15px; /* Match card padding */
            transform: rotate(180deg); /* Upside down */
        }

        /* Animation classes */
        .card.hidden-top {
            transform: translateY(-150%) rotateY(180deg); /* Start off-screen top, showing back face */
            opacity: 0;
        }
        .card.visible-center {
            transform: translateY(0) rotateY(180deg); /* End at center, showing back face */
            opacity: 1;
        }
        .card.exit-right { /* Changed from exit-down */
            transform: translateX(150%) rotateY(180deg); /* Move right and keep back face visible as it exits */
            opacity: 0;
            z-index: 2; /* Ensure the exiting card is on top */
        }

        /* Questions Container Styling */
        #questions-container {
            margin-top: 30px; /* Space between card and questions */
            width: 90%;
            max-width: 600px;
            padding: 20px;
            background-color: #1a202c; /* Dark background */
            border-radius: 0.5rem;
            box-shadow: 0 5px 15px -3px rgba(0, 0, 0, 0.2);
            z-index: 1; /* Above background */
        }
        .question-item {
            font-family: monospace;
            font-size: 1rem;
            color: #00FF00; /* Green color for questions */
            margin-bottom: 10px;
            min-height: 1.2em; /* Ensure space even when empty for typing effect */
        }

        /* Combined Footer Links Container Styling */
        .bottom-right-links {
            position: fixed; /* Fixed position relative to viewport */
            bottom: 20px; /* 20px from bottom */
            right: 20px; /* 20px from right */
            display: flex; /* Arrange items in a row */
            gap: 15px; /* Space between links */
            z-index: 10; /* Ensure it's on top of everything */
        }

        .footer-link {
            font-size: 2.5rem; /* Large emoji size */
            text-decoration: none; /* Remove underline */
            transition: transform 0.2s ease-in-out;
        }

        .footer-link:hover {
            transform: scale(1.1); /* Slightly enlarge on hover */
        }

        /* Scroll Indicator Styling */
        #scroll-indicator {
            position: fixed;
            bottom: 80px; /* Position slightly above footer links */
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            color: rgba(0, 255, 0, 0.7); /* Green arrow */
            animation: bounce 1s infinite; /* Gentle bounce animation */
            z-index: 9; /* Below footer links, above most content */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* Do not block clicks */
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateX(-50%) translateY(0);
            }
            40% {
                transform: translateX(-50%) translateY(-10px);
            }
            60% {
                transform: translateX(-50%) translateY(-5px);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            .main-title {
                font-size: 2rem; /* Smaller title on mobile */
                padding-top: 10px; /* Less padding on mobile */
            }
            #header-spacer {
                height: 80px; /* Adjust spacer height for mobile */
            }
            .card-container {
                width: 200px; /* Proportional width for mobile */
                height: 320px; /* Proportional height for mobile (200 * 40/25 = 320) */
            }
            .card-front {
                font-size: 1.5rem; /* Adjusted font size on small screens */
            }
            .card-back {
                font-size: 0.95rem; /* Adjusted font size on small screens */
                line-height: 1.4rem;
            }
            .scenario-id {
                font-size: 0.6rem; /* Smaller ID font on mobile */
            }
            #questions-container {
                padding: 15px;
                font-size: 0.9rem;
            }
            .bottom-right-links {
                gap: 10px; /* Smaller gap on mobile */
                bottom: 10px;
                right: 10px;
            }
            .footer-link {
                font-size: 2rem; /* Smaller emoji on mobile */
            }
            #scroll-indicator {
                font-size: 1.5rem;
                bottom: 60px; /* Adjust for smaller combined links */
            }
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-height: 100vh; p-4">
    <canvas id="background-canvas"></canvas>
    <h1 id="mainTitle" class="main-title">Cybersecurity Wargames</h1>
    <div id="header-spacer"></div> <!-- Spacer div -->
    <div class="card-container">
        <!-- Card elements will be dynamically managed by JavaScript -->
    </div>
    <div id="questions-container">
        <!-- Questions will appear here -->
    </div>

    <!-- Combined Links Container (fixed to bottom right) -->
    <div class="bottom-right-links">
        <a href="https://bio.site/tomtrott" target="_blank" class="footer-link" aria-label="My Bio Site">👨‍💻</a>
        <a href="mailto:mail-tomtrott@proton.me" class="footer-link" aria-label="Email me">💌</a>
        <a href="https://coff.ee/tomtrott" target="_blank" class="footer-link" aria-label="Buy me a coffee">☕</a>
    </div>

    <!-- Scroll Indicator Arrow -->
    <div id="scroll-indicator">▼</div>

    <script>
        // Raw CSV data from the provided file
        const csvData = `Scenario ID,Scenario
SCEN001,An employee has handed you a USB stick they found in the car park.
SCEN002,An internal web application is reporting dozens of failed login attempts from various IP addresses.
SCEN003,Network logs are showing significant and sustained increase in bandwidth consumption from a single internal IP during off-peak hours.
SCEN004,"Your XDR is reporting multiple unauthorized devices appearing in network scans, attempting to communicate with external IPs."
SCEN005,Network logs are showing unusual traffic spikes at irregular intervals from multiple devices within your network.
SCEN006,Network logs are showing traffic on port 4444 from multiple internal devices.
SCEN007,Multiple users are reporting that their company laptops have run out of internal storage space.
SCEN008,"An unknown process is running on a server, consuming unusually high CPU."
SCEN009,Your XDR is reporting modifications to critical system files on a server.
SCEN010,An unrecognised application on a user's laptop is generating a high number of outbound connections to various external IP addresses.
SCEN011,Your SIEM is reporting a new administrative account created for an application. You cannot find any record of a request or approval for this new account.
SCEN012,Network logs show multiple devices are making outbound connections to a known malicious IP address.
SCEN013,Your SIEM has detected many failed login attempts to multiple user accounts within a short period.
SCEN016,Network monitoring tools have detected HTTP requests with uncommon header types from an internal server to an external IP address.
SCEN017,A user behavior analysis tool has flagged a user suddenly downloading large amounts of data.
SCEN018,A database administrator shares a suspicion that there have been unauthorised changes to data.
SCEN019,Your CEO direct messages you to report that they have left their company laptop on a plane.
SCEN020,A member of the leadership team reports their company phone missing.
SCEN021,An employee mentions offhand that their personal phone has been stolen.
SCEN022,A shared testing device is missing from the office with no record of it being borrowed.
SCEN023,Two employees have reported a suspicious person attempting to access the office by tailgating.
SCEN024,An unrecognised external user keeps joining internal video calls.
SCEN025,An employee has received an abusive email from an internal service account.
SCEN026,"An employee has recieved a phone call claiming to be from Payroll, asking them to confirm their bank details."
SCEN027,A user has received a phone call from their company credit card issuer reporting suspicious activity.
SCEN028,"An employee has scanned a QR code sent to them in an email, and since then, their phone has been getting very hot."
SCEN029,Your public website is displaying a message supporting Russia's invasion of Ukraine.
SCEN030,An employee keeps receiving a warning message that their screen is being recorded.
SCEN031,An employee has shared sensitive company information on a public Discord channel.
SCEN032,A former employee posts on LinkedIn claiming the company's product contains critical security flaws.
SCEN033,Several company devices are displaying messages saying their storage is encrypted and asking for a ransom to be paid in Bitcoin.
SCEN034,You have discovered a feed from the building CCTV cameras on streaming on the dark web.
SCEN035,An employee has installed Tor browser on their company device.
SCEN036,A company Github repo was incorrectly set as public when it was created over a year ago.
SCEN037,The CEO of your company keeps reporting their Okta account as locked.
SCEN038,The CFO of your company complains that they cannot share company documents with their personal Google account.
SCEN039,"You discover a Post-it on a company whiteboard which reads, ""Usr: admin, passwd: 0dyss3y"""
SCEN040,The building management company have reported an unauthorised webcam discovered in the building's underground bike storage.
SCEN041,You witness an employee printing out company documents and packing them in their rucksack to take home.
SCEN042,You notice that an employee has called in sick on the day of mandatory security training for the second year in a row.
SCEN043,Your SIEM is reporting an AWS security group open to the world.
SCEN044,OWASP Dependency Check has reported several critical vulnerabilities in your application's live code.
SCEN045,An employee posts the office Wi-Fi password in a company-wide WhatsApp group.
SCEN046,You notice that a recent delivery to the office had the door entry code included in the delivery instructions.
SCEN047,An employee mentions that they back up their work laptop to a personal NAS box.
SCEN048,You discover a cybersquatting domain that has duplicated your public website.
SCEN049,You notice an external Slack account in a company channel that has the same name and profile as an internal account.
SCEN050,"You receive a WhatsApp message claiming to be from the CEO, asking for a quick call to discuss an urgent issue."
SCEN051,ChatGPT is recommending code snippets identical to your organisation's proprietary code.
SCEN052,Several users email you to ask why you are sending them spam.`;

        // Updated Questions CSV Data
        const questionsCsvData = `Questions
Is this is a security incident?
How would you detect this?
What questions does this raise?
Who would you speak to about this?
What actions would you take?
What's really happening here?
Does this suggest something suspicious?
What protections can you put in place to prevent this?
What do you do first?
Which elements of the CIA triad are affected?
What's the risk here?
Is this scenario high-risk or low-risk?
Is this an attack or a vulnerability?
Is there a name for this?
What do you stand to lose?
What's the worse-case scenario?
Do you have controls in place for this?
Is there another layer of defence you can add?
How worried do you feel?
Is this a red alert?`;


        let allScenarios = []; // Stores all parsed scenarios
        let availableScenarios = []; // Scenarios not yet drawn in current session
        let lastUsedFontIndex = -1; // Track the index of the last used font
        let lastUsedGradientIndex = -1; // Track the index of the last used gradient

        let allQuestions = []; // Stores all parsed questions
        let availableQuestionsForCurrentCard = []; // Questions available for the current card
        let questionsUsedOnPreviousCard = []; // Questions used on the previous card
        let currentQuestionTimers = []; // To store setTimeout IDs for questions


        const cardContainer = document.querySelector('.card-container'); // Reference to the container
        let currentCardElement = null; // Reference to the currently active/visible card
        const questionsContainer = document.getElementById('questions-container'); // Reference to questions container
        const mainTitleElement = document.getElementById('mainTitle'); // Reference to the title element
        const headerSpacer = document.getElementById('header-spacer'); // Reference to the spacer element
        const scrollIndicator = document.getElementById('scroll-indicator'); // Reference to scroll indicator


        // List of League of Moveable Type fonts available on Google Fonts (both serif and sans-serif)
        const leagueFonts = [
            "'Sorts Mill Goudy', serif",
            "'Linden Hill', serif",
            "'Goudy Bookletter 1911', serif",
            "'Fanwood Text', serif",
            "'League Gothic', sans-serif",
            "'League Spartan', sans-serif",
            "'Raleway', sans-serif"
        ];

        // List of appealing gradient color pairs, adjusted for better contrast with white text
        const gradientColors = [
            // Purple gradients
            ['#4B0082', '#8A2BE2'], // Indigo to Blue Violet
            ['#6A0572', '#AB47BC'], // Dark Magenta to Purple
            // Blue gradients
            ['#00008B', '#4169E1'], // Dark Blue to Royal Blue
            ['#004080', '#0080FF'], // Navy Blue to Azure
            // Red gradients
            ['#8B0000', '#DC143C'], // Dark Red to Crimson
            ['#A52A2A', '#CD5C5C'], // Brown to Indian Red
            // Green gradients
            ['#006400', '#228B22'], // Dark Green to Forest Green
            ['#2E8B57', '#3CB371'], // Sea Green to Medium Sea Green
            // Orange gradients
            ['#FF4500', '#FF8C00'], // Orange Red to Dark Orange
            ['#D2691E', '#FF7F50']  // Chocolate to Coral
        ];

        /**
         * Parses CSV string data into an array of objects.
         * Assumes the first row is the header.
         * Handles quoted fields and newlines within fields.
         * @param {string} csv - The CSV data as a string.
         * @returns {Array<Object>} An array of objects, where each object represents a row.
         */
        function parseCSV(csv) {
            const lines = csv.split(/\r?\n/); // Split by newline, handling both \n and \r\n
            // Filter out empty lines before processing headers and data
            const nonEmptyLines = lines.filter(line => line.trim() !== '');

            if (nonEmptyLines.length === 0) {
                return []; // Return empty array if no valid data
            }

            const headers = nonEmptyLines[0].split(',').map(header => header.trim()); // Get headers and trim whitespace
            const result = [];

            for (let i = 1; i < nonEmptyLines.length; i++) {
                const line = nonEmptyLines[i].trim();
                if (!line) continue; // Should already be filtered, but double-check

                const obj = {};
                let inQuote = false;
                let currentField = '';
                let fieldIndex = 0;

                for (let j = 0; j < line.length; j++) {
                    const char = line[j];

                    if (char === '"') {
                        inQuote = !inQuote; // Toggle quote state
                        if (!inQuote && line[j + 1] === '"') { // Handle escaped quotes ""
                            currentField += '"';
                            j++; // Skip the next quote
                        }
                    } else if (char === ',' && !inQuote) {
                        // End of field
                        if (headers[fieldIndex]) { // Ensure header exists
                            obj[headers[fieldIndex]] = currentField.trim();
                        }
                        currentField = '';
                        fieldIndex++;
                    } else {
                        currentField += char;
                    }
                }
                // Add the last field
                if (headers[fieldIndex]) { // Ensure header exists for the last field
                    obj[headers[fieldIndex]] = currentField.trim();
                }
                result.push(obj);
            }
            return result;
        }

        /**
         * Selects a random scenario from the availableScenarios array and removes it.
         * @returns {Object|null} A random scenario object, or null if no scenarios are available.
         */
        function getRandomScenario() {
            if (availableScenarios.length === 0) {
                return null;
            }
            const randomIndex = Math.floor(Math.random() * availableScenarios.length);
            const selectedScenario = availableScenarios[randomIndex];
            availableScenarios.splice(randomIndex, 1); // Remove the selected scenario
            return selectedScenario;
        }

        /**
         * Selects a random question from the availableQuestionsForCard pool.
         * Ensures no immediate repetition from the previous card, and no repetition on the current card.
         * @returns {string|null} A random question string, or null if no questions are available.
         */
        function getRandomQuestion() {
            // This function now just picks one random question from the current availableQuestionsForCurrentCard pool
            if (availableQuestionsForCurrentCard.length === 0) {
                return null;
            }
            const randomIndex = Math.floor(Math.random() * availableQuestionsForCurrentCard.length);
            const selectedQuestion = availableQuestionsForCurrentCard[randomIndex];
            availableQuestionsForCurrentCard.splice(randomIndex, 1); // Remove from current card's pool
            return selectedQuestion;
        }


        /**
         * Applies a random font from the leagueFonts array to the card's back face,
         * ensuring it's not the same as the last used font.
         * @param {HTMLElement} cardBackElement - The back face element of the card.
         */
        function applyRandomFont(cardBackElement) {
            let newFontIndex;
            do {
                newFontIndex = Math.floor(Math.random() * leagueFonts.length);
            } while (newFontIndex === lastUsedFontIndex && leagueFonts.length > 1); // Ensure a different font if more than one is available

            cardBackElement.style.fontFamily = leagueFonts[newFontIndex];
            lastUsedFontIndex = newFontIndex; // Update the last used font index
        }

        /**
         * Applies a random gradient background to both card faces,
         * ensuring it's not the same as the last used gradient.
         * @param {HTMLElement} cardFrontElement - The front face element of the card.
         * @param {HTMLElement} cardBackElement - The back face element of the card.
         */
        function applyRandomGradient(cardFrontElement, cardBackElement) {
            let newGradientIndex;
            do {
                newGradientIndex = Math.floor(Math.random() * gradientColors.length);
            } while (newGradientIndex === lastUsedGradientIndex && gradientColors.length > 1); // Ensure a different gradient if more than one is available

            const [color1, color2] = gradientColors[newGradientIndex];
            cardFrontElement.style.background = `linear-gradient(135deg, ${color1}, ${color2})`;
            cardBackElement.style.background = `linear-gradient(135deg, ${color2}, ${color1})`; // Reversed for back
            lastUsedGradientIndex = newGradientIndex; // Update the last used gradient index
        }

        /**
         * Adjusts the font size of the scenario text to fill the card,
         * allowing it to wrap over several lines, with a suitable buffer,
         * and ensuring no scrollbar appears.
         * @param {HTMLElement} element - The text element to adjust (scenarioTextElement).
         * @param {HTMLElement} container - The container element (cardBack).
         */
        function adjustFontSize(element, container) {
            let fontSize = 100; // Start with a very large font size to push limits
            element.style.fontSize = fontSize + 'px';
            element.style.whiteSpace = 'normal'; // Ensure text wraps
            element.style.lineHeight = '1.2em'; // Use em for line-height relative to font size

            const maxIterations = 200; // Increased iterations for more precision
            let iterations = 0;

            // Get the effective inner dimensions of the container (cardBack)
            const containerStyle = getComputedStyle(container);
            const containerHeight = container.clientHeight - (parseFloat(containerStyle.paddingTop) + parseFloat(containerStyle.paddingBottom));
            const containerWidth = container.clientWidth - (parseFloat(containerStyle.paddingLeft) + parseFloat(containerStyle.paddingRight));

            // Define a minimal buffer to maximize space utilization without overflow
            const buffer = 0; // 0 pixels buffer to truly maximize space
            const minFontSize = 12; // Minimum readable font size

            // Phase 1: Shrink if overflow occurs (vertical or horizontal)
            // This loop ensures the text *never* overflows the container.
            while ((element.scrollHeight > containerHeight - buffer || element.scrollWidth > containerWidth - buffer) && fontSize > minFontSize && iterations < maxIterations) {
                fontSize -= 0.5;
                element.style.fontSize = fontSize + 'px';
                iterations++;
            }

            // Phase 2: Grow to fill space if there's significant empty space, without causing overflow
            // This loop tries to make the text as large as possible.
            iterations = 0;
            const maxAllowedFontSize = 120; // Even higher maximum allowed font size
            const growthStep = 0.5; // Step for increasing font size

            while (fontSize < maxAllowedFontSize && iterations < maxIterations) {
                // Temporarily increase font size and check if it causes overflow
                element.style.fontSize = (fontSize + growthStep) + 'px';
                if (element.scrollHeight > containerHeight - buffer || element.scrollWidth > containerWidth - buffer) {
                    element.style.fontSize = fontSize + 'px'; // Revert to previous size if it overflows
                    break; // Stop increasing
                }
                fontSize += growthStep;
                iterations++;
            }
        }


        /**
         * Creates a new card element and populates it with scenario data.
         * @param {Object} scenario - The scenario object.
         * @returns {Object} An object containing the cardDiv, scenarioP, cardFrontDiv, and cardBackDiv.
         */
        function createCardElement(scenario) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card'; // Apply base card styles

            const cardFrontDiv = document.createElement('div');
            cardFrontDiv.className = 'card-face card-front';

            const cardBackDiv = document.createElement('div');
            cardBackDiv.className = 'card-face card-back';
            const scenarioP = document.createElement('p');
            scenarioP.className = 'scenario-text'; // Class for text element for sizing

            // Scenario ID elements
            const scenarioIdTopLeft = document.createElement('span');
            scenarioIdTopLeft.className = 'scenario-id scenario-id-top-left';
            const scenarioIdBottomRight = document.createElement('span');
            scenarioIdBottomRight.className = 'scenario-id scenario-id-bottom-right';


            if (scenario && scenario.Scenario) {
                scenarioP.textContent = scenario.Scenario;
                scenarioIdTopLeft.textContent = scenario['Scenario ID'];
                scenarioIdBottomRight.textContent = scenario['Scenario ID'];
                applyRandomFont(cardBackDiv); // Apply font to the back face
                applyRandomGradient(cardFrontDiv, cardBackDiv); // Apply gradient to both faces
            } else {
                scenarioP.textContent = "You've viewed all the cards. Want to buy me a coffee?"; // Updated text
                // Default styles for the "all scenarios viewed" message
                cardBackDiv.style.fontFamily = "'Sorts Mill Goudy', serif";
                cardFrontDiv.style.background = `linear-gradient(135deg, #4A607A, #2C3E50)`;
                cardBackDiv.style.background = `linear-gradient(135deg, #2C3E50, #4A607A)`;
                cardDiv.style.pointerEvents = 'none'; // Disable clicks if no scenarios
            }

            cardBackDiv.appendChild(scenarioP);
            cardBackDiv.appendChild(scenarioIdTopLeft); // Add ID to back face
            cardBackDiv.appendChild(scenarioIdBottomRight); // Add ID to back face
            cardDiv.appendChild(cardFrontDiv);
            cardDiv.appendChild(cardBackDiv);

            // Start off-screen, rotated to show back. Opacity will be set by displayCard.
            cardDiv.classList.add('hidden-top');

            return { cardDiv, scenarioP, cardFrontDiv, cardBackDiv }; // Return elements needed for sizing
        }

        /**
         * Displays a card element with animation and adjusts font size.
         * @param {Object} scenario - The scenario object.
         * @param {HTMLElement} cardElement - The new card div element to display.
         * @param {HTMLElement} textElement - The <p> element inside the card.
         * @param {HTMLElement} backFaceElement - The back face div of the card.
         */
        function displayCard(scenario, cardElement, textElement, backFaceElement) {
            // Force a reflow to ensure the initial state is applied before the transition
            void cardElement.offsetWidth;

            // Animate the card into the center
            cardElement.classList.remove('hidden-top');
            cardElement.classList.add('visible-center');

            // Adjust font size after the card is in position and content is rendered
            setTimeout(() => {
                adjustFontSize(textElement, backFaceElement);
                // Start displaying questions after the card is fully visible and sized
                if (scenario && scenario.Scenario) { // Only display questions if it's a valid scenario card
                    displayQuestions();
                } else {
                    scrollIndicator.style.opacity = 0; // Hide scroll indicator if no questions
                }
            }, 50); // Shorter delay for responsiveness
        }

        /**
         * Simulates typing text into an HTML element.
         * @param {HTMLElement} element - The element to type into.
         * @param {string} text - The text to type.
         * @param {number} speed - Typing speed in milliseconds per character.
         * @returns {Promise<void>} A promise that resolves when typing is complete.
         */
        function typeText(element, text, speed = 50) {
            element.textContent = ''; // Clear content first
            let i = 0;
            return new Promise(resolve => {
                function type() {
                    if (i < text.length) {
                        element.textContent += text.charAt(i);
                        i++;
                        setTimeout(type, speed);
                    } else {
                        resolve();
                    }
                }
                type();
            });
        }

        /**
         * Displays three random questions with typing animation and timed delays.
         */
        function displayQuestions() {
            // Clear any existing timers and questions
            currentQuestionTimers.forEach(timer => clearTimeout(timer));
            currentQuestionTimers = [];
            questionsContainer.innerHTML = '';
            scrollIndicator.style.opacity = 0; // Hide initially

            // Prepare questions for the current card
            const questionsToDisplay = [];
            let tempAvailableQuestionsPool = [...allQuestions.map(q => q.Questions)]; // Start with all questions
            const questionsToExclude = new Set(questionsUsedOnPreviousCard);

            // Filter out questions used on the previous card from the temporary pool
            let filteredQuestions = tempAvailableQuestionsPool.filter(q => !questionsToExclude.has(q));

            // If, after excluding previous card's questions, we don't have enough unique questions
            // for this card (e.g., less than 3), then we reset questionsUsedOnPreviousCard
            // and use the full set of all questions for this card's pool.
            if (filteredQuestions.length < 3 && allQuestions.length >= 3) {
                questionsUsedOnPreviousCard = []; // Clear history for the *next* card
                filteredQuestions = [...allQuestions.map(q => q.Questions)]; // Use all questions for this card
            } else if (allQuestions.length < 3) {
                // If the total number of questions is less than 3, just use what's available
                filteredQuestions = [...allQuestions.map(q => q.Questions)];
            }

            // Select 3 unique questions for the current card from the filtered pool
            // Ensure we don't try to pick more questions than are available in filteredQuestions
            for (let i = 0; i < Math.min(3, filteredQuestions.length); i++) {
                const randomIndex = Math.floor(Math.random() * filteredQuestions.length);
                const selectedQuestion = filteredQuestions[randomIndex];
                questionsToDisplay.push(selectedQuestion);
                filteredQuestions.splice(randomIndex, 1); // Remove from this card's pool to ensure uniqueness on this card
            }

            // Store the questions actually displayed on this card for the *next* card's exclusion
            questionsUsedOnPreviousCard = questionsToDisplay;

            questionsToDisplay.forEach((questionText, index) => {
                const questionElement = document.createElement('p');
                questionElement.className = 'question-item';
                questionsContainer.appendChild(questionElement);

                // Corrected delay: first question waits 40s, subsequent ones are 40s after that.
                const delay = (index * 40000) + 40000; // First question waits 40s (0*40000 + 40000), second 80s (1*40000 + 40000), etc.
                const timer = setTimeout(() => {
                    typeText(questionElement, questionText, 50); // Typing speed 50ms per char
                }, delay);
                currentQuestionTimers.push(timer);
            });

            // Check for overflow after questions are added to the DOM (even if typing is delayed)
            setTimeout(() => {
                if (questionsContainer.scrollHeight > questionsContainer.clientHeight) {
                    scrollIndicator.style.opacity = 1; // Show if content overflows
                } else {
                    scrollIndicator.style.opacity = 0; // Hide if content fits
                }
            }, 100); // Small delay to allow DOM rendering and scrollHeight calculation
        }


        /**
         * Handles the click event on the card to draw a new scenario.
         */
        function handleCardClick() {
            // Temporarily disable click on the current card
            if (currentCardElement) {
                currentCardElement.style.pointerEvents = 'none';
                // Remove the old event listener
                currentCardElement.removeEventListener('click', handleCardClick);
            }

            // Clear any pending question timers
            currentQuestionTimers.forEach(timer => clearTimeout(timer));
            currentQuestionTimers = [];
            questionsContainer.innerHTML = ''; // Clear questions immediately
            scrollIndicator.style.opacity = 0; // Hide scroll indicator immediately

            // Get the next scenario. This will also update availableScenarios.
            const nextScenario = getRandomScenario();

            if (nextScenario === null) {
                // All scenarios have been viewed.
                // Modify the *current* card to show the "All scenarios viewed" message.
                // No new card creation or animation needed.
                const scenarioP = currentCardElement.querySelector('.scenario-text');
                const cardFrontDiv = currentCardElement.querySelector('.card-face.card-front');
                const cardBackDiv = currentCardElement.querySelector('.card-face.card-back');

                scenarioP.textContent = "You've viewed all the cards. Want to buy me a coffee?"; // Updated text
                // Apply default readable font and gradient for the "all scenarios viewed" message
                cardBackDiv.style.fontFamily = "'Sorts Mill Goudy', serif";
                cardFrontDiv.style.background = `linear-gradient(135deg, #4A607A, #2C3E50)`;
                cardBackDiv.style.background = `linear-gradient(135deg, #2C3E50, #4A607A)`;
                
                // Adjust font size for the new message
                setTimeout(() => {
                    adjustFontSize(scenarioP, cardBackDiv);
                }, 50);

                // Ensure the card remains unclickable
                currentCardElement.style.pointerEvents = 'none';
                return; // Stop further execution
            }

            // If there is a next scenario, proceed with the animation
            const { cardDiv: newCardElement, scenarioP: newScenarioTextElement, cardFrontDiv: newCardFrontDiv, cardBackDiv: newCardBackDiv } = createCardElement(nextScenario);

            // Append the new card to the container (it will be underneath due to z-index)
            cardContainer.appendChild(newCardElement);

            // Start the current card's exit animation
            if (currentCardElement) {
                currentCardElement.classList.remove('visible-center'); // Ensure it's not trying to stay centered
                currentCardElement.classList.add('exit-right'); // Changed to exit-right
                currentCardElement.style.zIndex = 2; // Ensure old card stays on top during exit

                // After the old card's animation completes, remove it
                currentCardElement.addEventListener('transitionend', function handler() {
                    this.removeEventListener('transitionend', handler);
                    this.remove(); // Remove the old card from DOM
                });
            }

            // Display the new card
            displayCard(nextScenario, newCardElement, newScenarioTextElement, newCardBackDiv);

            // Update the reference to the currently active card
            currentCardElement = newCardElement;

            // Re-enable click on the new card after animation is complete
            setTimeout(() => {
                currentCardElement.style.pointerEvents = 'auto';
                // Add the event listener to the new card
                currentCardElement.addEventListener('click', handleCardClick);
            }, 600); // Match animation duration
        }

        /**
         * Initializes the application: parses CSV and sets up event listeners.
         */
        function initializeApp() {
            allScenarios = parseCSV(csvData);
            allQuestions = parseCSV(questionsCsvData); // Parse questions data

            // Filter out scenarios where the 'Scenario' field is empty or just whitespace
            allScenarios = allScenarios.filter(s => s.Scenario && s.Scenario.trim() !== '');
            // Filter out questions where the 'Questions' field is empty or just whitespace
            allQuestions = allQuestions.filter(q => q.Questions && q.Questions.trim() !== '');


            // Initialize availableScenarios with a copy of allScenarios for the session
            availableScenarios = [...allScenarios];

            // Display the first card on page load
            const initialScenario = getRandomScenario();
            const { cardDiv, scenarioP, cardFrontDiv, cardBackDiv } = createCardElement(initialScenario);
            cardContainer.appendChild(cardDiv);
            currentCardElement = cardDiv;

            // For the initial card, we want it to immediately be visible-center, not animate from top
            currentCardElement.classList.remove('hidden-top'); // Remove the initial hidden-top state
            currentCardElement.classList.add('visible-center'); // Set it to visible-center directly

            // Adjust font size for the initial card
            setTimeout(() => {
                adjustFontSize(scenarioP, cardBackDiv);
                if (initialScenario && initialScenario.Scenario) { // Only display questions if it's a valid scenario card
                    displayQuestions();
                } else {
                    scrollIndicator.style.opacity = 0; // Hide scroll indicator if no questions
                }
            }, 50);

            // Add event listener to the card itself
            currentCardElement.addEventListener('click', handleCardClick);

            // If no scenarios are available initially, disable clicks
            if (initialScenario === null) {
                currentCardElement.style.pointerEvents = 'none';
            }
        }

        // --- Background Animation Logic ---
        const canvas = document.getElementById('background-canvas');
        const ctx = canvas.getContext('2d');
        let animationFrameId;
        const circuitFlows = []; // Renamed from 'lines'
        const codeSnippets = [];
        const snippetTexts = [
            'firewall_rule_set', 'packet_loss_detected', 'intrusion_alert_high', 'malware_signature_match',
            'phishing_attempt_logged', 'zero_day_exploit_found', 'ddos_mitigation_active', 'encryption_key_rotation',
            'vpn_connection_failed', 'access_denied_user', 'log_anomaly_detected', 'vulnerability_scan_init',
            'endpoint_isolated_net', 'data_exfil_attempt', 'root_privilege_escalation', 'security_patch_deploy',
            'threat_intelligence_feed', 'incident_response_plan', 'network_segmentation', 'mfa_bypass_attempt'
        ];

        // Resize canvas to fill window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Circuit Flow properties
        const maxFlows = 20; // Number of circuit flow animations
        const lineSpeed = 0.125; // Halved again from 0.25
        const flowLineColor = 'rgba(0, 255, 0, 0.1)'; // Faint green for circuit lines
        const flowDotColor = 'rgba(0, 255, 0, 0.5)'; // Brighter green for dots

        // Code snippet properties
        const maxSnippets = 15;
        const snippetSpeed = 0.2; // Halved again from 0.4
        const snippetColor = 'rgba(0, 191, 255, 0.3)'; // Cyan/Blue for code
        const snippetFontSize = 14;

        class CircuitFlow {
            constructor() {
                this.reset();
            }

            reset() {
                this.path = [];
                let currentX = Math.random() * canvas.width;
                let currentY = Math.random() * canvas.height;

                this.path.push({ x: currentX, y: currentY });

                const numSegments = Math.floor(Math.random() * 3) + 1; // 1 to 3 segments, resulting in 2 to 4 points
                let lastDirection = Math.random() < 0.5 ? 'horizontal' : 'vertical';

                for (let i = 0; i < numSegments; i++) {
                    let segmentLength = Math.random() * 100 + 50; // Random length for segment
                    let nextX = currentX;
                    let nextY = currentY;

                    // Determine direction for the next segment, alternating
                    if (lastDirection === 'horizontal') {
                        nextX += (Math.random() < 0.5 ? 1 : -1) * segmentLength;
                        lastDirection = 'vertical';
                    } else {
                        nextY += (Math.random() < 0.5 ? 1 : -1) * segmentLength;
                        lastDirection = 'horizontal';
                    }

                    // Clamp to canvas boundaries
                    nextX = Math.max(0, Math.min(canvas.width, nextX));
                    nextY = Math.max(0, Math.min(canvas.height, nextY));

                    // Add the new point
                    this.path.push({ x: nextX, y: nextY });
                    currentX = nextX;
                    currentY = nextY;
                }

                this.currentSegmentIndex = 0;
                this.progressInSegment = 0;
                this.speed = lineSpeed + Math.random() * 0.5;
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.path[0].x, this.path[0].y);
                for (let i = 1; i < this.path.length; i++) {
                    ctx.lineTo(this.path[i].x, this.path[i].y);
                }
                ctx.strokeStyle = flowLineColor;
                ctx.lineWidth = 1;
                ctx.stroke();

                const p1 = this.path[this.currentSegmentIndex];
                const p2 = this.path[this.currentSegmentIndex + 1];

                if (!p1 || !p2) {
                    return;
                }

                const currentX = p1.x + (p2.x - p1.x) * this.progressInSegment;
                const currentY = p1.y + (p2.y - p1.y) * this.progressInSegment;

                ctx.beginPath();
                ctx.arc(currentX, currentY, 2, 0, Math.PI * 2);
                ctx.fillStyle = flowDotColor;
                ctx.fill();
            }

            update() {
                if (this.path.length < 2) {
                    this.reset();
                    return;
                }

                const p1 = this.path[this.currentSegmentIndex];
                const p2 = this.path[this.currentSegmentIndex + 1];

                if (!p1 || !p2) {
                    return;
                }

                const segmentLength = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

                if (segmentLength === 0) {
                    this.progressInSegment = 1;
                } else {
                    this.progressInSegment += this.speed / segmentLength;
                }

                if (this.progressInSegment >= 1) {
                    this.progressInSegment = 0;
                    this.currentSegmentIndex++;
                    if (this.currentSegmentIndex >= this.path.length - 1) {
                        this.reset();
                    }
                }
            }
        }

        class CodeSnippet {
            constructor() {
                this.text = snippetTexts[Math.floor(Math.random() * snippetTexts.length)];
                this.x = Math.random() * canvas.width;
                this.y = -Math.random() * canvas.height;
                this.speed = snippetSpeed + Math.random() * 0.5;
                this.opacity = 0;
                this.fadeIn = true;
                this.life = 0;
                this.maxLife = Math.random() * 200 + 100;
            }

            draw() {
                ctx.font = `${snippetFontSize}px monospace`;
                ctx.fillStyle = snippetColor.replace(')', `, ${this.opacity})`);
                ctx.fillText(this.text, this.x, this.y);
            }

            update() {
                this.y += this.speed;
                this.life++;

                if (this.fadeIn) {
                    this.opacity += 0.01;
                    if (this.opacity >= 1) {
                        this.opacity = 1;
                        this.fadeIn = false;
                    }
                } else if (this.life > this.maxLife * 0.7) {
                    this.opacity -= 0.01;
                    if (this.opacity <= 0) {
                        this.reset();
                    }
                }

                if (this.y > canvas.height + 50) {
                    this.reset();
                }
            }

            reset() {
                this.text = snippetTexts[Math.floor(Math.random() * snippetTexts.length)];
                this.x = Math.random() * canvas.width;
                this.y = -Math.random() * canvas.height;
                this.speed = snippetSpeed + Math.random() * 0.5;
                this.opacity = 0;
                this.fadeIn = true;
                this.life = 0;
                this.maxLife = Math.random() * 200 + 100;
            }
        }

        function initBackgroundAnimation() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            for (let i = 0; i < maxFlows; i++) {
                circuitFlows.push(new CircuitFlow());
            }
            for (let i = 0; i < maxSnippets; i++) {
                codeSnippets.push(new CodeSnippet());
            }

            animateBackground();
        }

        function animateBackground() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(0, 255, 0, 0.05)';
            ctx.lineWidth = 0.5;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            circuitFlows.forEach(flow => {
                flow.update();
                flow.draw();
            });

            codeSnippets.forEach(snippet => {
                snippet.update();
                snippet.draw();
            });

            animationFrameId = requestAnimationFrame(animateBackground);
        }

        document.addEventListener('DOMContentLoaded', initBackgroundAnimation);
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
